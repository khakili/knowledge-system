# 万恶之源：可见性、有序性及原子性问题

## 并发程序幕后的故事

在计算机中，CPU、内存、I/O一直都存在速度的差异。程序里大部分语句都需要访问内存，有些还要访问I/O，根据木桶理论，程序整体性能取决于最慢的操作。

为了合理利用CPU的高性能，平衡三者差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：

> * CUP增加了缓存，以均衡与内存的速度差异
> * 操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；
> * 编译程序优化指令执行次序，使得缓存能够得到更加合理的利用。

并发程序很多诡异问题的根源也在这里。

## 源头之一：缓存导致的可见性问题

在单核时代，所有线程都在一颗CPU上运行，所以CPU缓存与内存的数据一致性就容易解决，因为所有线程都操作一个CPU的缓存，一个线程对缓存的写对另外一个线程来说一定是可见的。

![](images/origin/one_cpu.png)

一个线程对共享变量的修改，另外一个线程能立刻看到，我们成为**可见性**。

多核时代，每颗CPU都有自己的缓存，这时CPU缓存与内存的数据一致性就没那么容易解决了。

![](images/origin/more_cpu.png)

## 源头之二：线程切换带来的原子性问题

## 源头之三：编译优化带来的有序性问题

总结




